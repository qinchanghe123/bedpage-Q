<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>é¡¶æµå¹¿å‘ŠæŠ€æœ¯æœ‰é™å…¬å¸</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container { 
      max-width: 900px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      position: relative;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
      font-size: 2.5em;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 700;
    }

    .subtitle {
      text-align: center;
      color: #7f8c8d;
      font-size: 1.1em;
      margin-bottom: 40px;
      font-weight: 300;
    }

    .radar-badge {
      position: absolute;
      top: 20px;
      right: 20px;
      background: #000;
      color: #fff;
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
      opacity: 0.8;
    }

    .input-group { 
      margin-bottom: 30px;
      position: relative;
    }

    .input-wrapper {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 15px;
    }

    #addressInput { 
      flex: 1;
      font-size: 16px;
      padding: 15px 20px;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      outline: none;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.9);
    }

    #addressInput:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-2px);
    }

    button { 
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      padding: 15px 30px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover { 
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
    }

    button:active {
      transform: translateY(0);
    }
    
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .service-label {
      color: #667eea;
      font-weight: 600;
      font-size: 14px;
      text-align: center;
      margin-top: 10px;
      padding: 8px 16px;
      background: rgba(102, 126, 234, 0.1);
      border-radius: 20px;
      display: inline-block;
      border: 1px solid rgba(102, 126, 234, 0.2);
    }

    .results, .error, .loading, .location-info { 
      margin-top: 30px;
      animation: fadeInUp 0.5s ease;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .error { 
      color: #e74c3c;
      font-weight: 600;
      padding: 15px;
      background: rgba(231, 76, 60, 0.1);
      border-left: 4px solid #e74c3c;
      border-radius: 8px;
    }

    .loading { 
      text-align: center;
      color: #667eea;
      font-size: 18px;
      font-weight: 500;
    }

    .location-info { 
      padding: 20px;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border-left: 4px solid #667eea;
      border-radius: 12px;
      color: #2c3e50;
      font-weight: 500;
    }

    table { 
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
    }

    th, td { 
      padding: 16px 20px;
      text-align: left;
      border-bottom: 1px solid #f0f0f0;
    }

    th { 
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 14px;
      letter-spacing: 0.5px;
    }

    tr:hover {
      background: rgba(102, 126, 234, 0.05);
      transform: scale(1.01);
      transition: all 0.2s ease;
    }

    a.nav-link { 
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
      padding: 8px 16px;
      border: 2px solid #667eea;
      border-radius: 20px;
      transition: all 0.3s ease;
      display: inline-block;
    }

    a.nav-link:hover { 
      background: #667eea;
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    .progress-container { 
      width: 100%;
      background: #f0f0f0;
      border-radius: 25px;
      height: 8px;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      display: none;
    }

    .progress-bar { 
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      width: 0;
      transition: width 0.3s ease;
      border-radius: 25px;
      position: relative;
    }

    .progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-text { 
      margin-top: 10px;
      color: #667eea;
      font-size: 14px;
      text-align: center;
      font-weight: 500;
      min-height: 21px; /* é˜²æ­¢æŠ–åŠ¨ */
    }

    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(102, 126, 234, 0.3);
      border-radius: 50%;
      border-top-color: #667eea;
      animation: spin 1s ease-in-out infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        margin: 10px;
        padding: 20px;
        border-radius: 15px;
      }

      h1 {
        font-size: 2em;
      }

      .input-wrapper {
        flex-direction: column;
      }

      #addressInput {
        margin-bottom: 15px;
      }

      table {
        font-size: 14px;
      }

      th, td {
        padding: 12px 8px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>é¡¶æµå¹¿å‘ŠæŠ€æœ¯æœ‰é™å…¬å¸</h1>
    <div class="subtitle">ğŸ“ Bedpageå®šç‚¹æŸ¥è¯¢ </div>
    
    <div class="input-group">
      <div class="input-wrapper">
        <input id="addressInput" type="text" placeholder="ç¤ºä¾‹: 123 Main St, Los Angeles, CA" />
        <button id="btnSearch">ğŸ” å¼€å§‹æŸ¥è¯¢</button>
      </div>
      <div style="text-align: center;">
        <span class="service-label">ğŸ“ Bedpageå®šç‚¹æŸ¥è¯¢</span>
      </div>
    </div>

    <div class="progress-container" id="progressContainer">
      <div class="progress-bar" id="progressBar"></div>
    </div>
    <div class="progress-text" id="progressText"></div>
    
    <div id="loading" class="loading" style="display:none;">
      <div class="status-indicator">
        <div class="loading-spinner"></div>
        <span id="loadingText">æ­£åœ¨æ™ºèƒ½è®¡ç®—ä¸­ï¼Œè¯·ç¨å€™...</span>
      </div>
    </div>
    
    <div id="error" class="error" style="display:none;"></div>
    <div id="locationInfo" class="location-info" style="display:none;"></div>
    <div id="results" class="results"></div>
  </div>

<script>
// *** 1. é…ç½® ***
const RADAR_PUBLISHABLE_KEY = "prj_live_pk_2e373aa83c20426825149e2299571e9d1ce4d5e9";
let bedpageData = null;

// *** DOM å…ƒç´ å¼•ç”¨ ***
const btn = document.getElementById('btnSearch');
const addressInput = document.getElementById('addressInput');
const loadingEl = document.getElementById('loading');
const loadingTextEl = document.getElementById('loadingText');
const errorEl = document.getElementById('error');
const resultsEl = document.getElementById('results');
const locationInfoEl = document.getElementById('locationInfo');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');

// *** äº‹ä»¶ç›‘å¬ ***
btn.onclick = handleSearch;
addressInput.addEventListener('keypress', (event) => {
    if (event.key === 'Enter') handleSearch();
});

async function loadBedpageData() {
    if (bedpageData) return bedpageData;
    try {
        const response = await fetch('./bedpage.json');
        if (!response.ok) throw new Error(`HTTP é”™è¯¯! çŠ¶æ€: ${response.status}`);
        bedpageData = await response.json();
        return bedpageData;
    } catch (error) {
        throw new Error("åŠ è½½åŸå¸‚æ•°æ®æ–‡ä»¶ (bedpage.json) å¤±è´¥ã€‚è¯·ç¡®ä¿æ–‡ä»¶å­˜åœ¨äºåŒä¸€ç›®å½•ã€‚");
    }
}

async function handleSearch() {
    const address = addressInput.value.trim();
    if (!address) {
        showError("è¯·è¾“å…¥åº—é“ºåœ°å€");
        return;
    }

    resetUI();
    showLoading("æ­£åœ¨è§£æåœ°å€...");

    try {
        if (!RADAR_PUBLISHABLE_KEY) throw new Error("æœªé…ç½® Radar Key");

        // æ­¥éª¤ 0: åŠ è½½æ•°æ®
        if (!bedpageData) {
            updateProgress(10, "æ­£åœ¨åŠ è½½æ•°æ®åº“...");
            await loadBedpageData();
        }

        // æ­¥éª¤ 1: Geocoding
        updateProgress(30, "æ­£åœ¨è§£æåœ°å€ä¿¡æ¯...");
        const geocodedResult = await geocodeAddress(address);
        const stateName = geocodedResult.address.state;
        const cityName = geocodedResult.address.city;
        const originPosition = geocodedResult.position;

        // æ˜¾ç¤ºå®šä½ä¿¡æ¯
        locationInfoEl.innerHTML = `<strong>ğŸ¯ åœ°å€è¯†åˆ«ä¿¡æ¯:</strong> æ‚¨è¾“å…¥çš„åœ°å€ä½äº <strong>${stateName}</strong> å·çš„ <strong>${cityName || 'æœªçŸ¥åŸå¸‚'}</strong>`;
        locationInfoEl.style.display = 'block';

        // æ­¥éª¤ 2: åŒ¹é…åŸå¸‚
        updateProgress(40, "æ­£åœ¨åŒ¹é…æœ€ä¼˜åŒºåŸŸ...");
        
        // 2.1 åŒ¹é…å·
        const stateKey = Object.keys(bedpageData).find(key => {
            const [name] = key.split('|');
            return name.trim().toLowerCase() === stateName.trim().toLowerCase() ||
                   (stateName.length === 2 && name.trim().toLowerCase().startsWith(stateName.toLowerCase())); 
        });

        if (!stateKey) throw new Error(`æ‚¨æ‰€åœ¨çš„å· "${stateName}" ä¸åœ¨æ”¯æŒåˆ—è¡¨å†…`);
        const stateObj = bedpageData[stateKey];

        // 2.2 åŒ¹é…åŸå¸‚ (åŒåæˆ–æœ€è¿‘)
        let cityKey = null;
        if (cityName) {
            cityKey = Object.keys(stateObj).find(key => {
                const [name] = key.split('|');
                return name.trim().toLowerCase() === cityName.trim().toLowerCase();
            });
        }

        let usedCityName = cityName || "æœªçŸ¥åŸå¸‚";

        // å¦‚æœæ²¡æœ‰åŒååŸå¸‚ï¼Œæ‰¾æœ€è¿‘çš„
        if (!cityKey) {
            updateProgress(50, "æ­£åœ¨è®¡ç®—æœ€è¿‘çš„åŸå¸‚èŠ‚ç‚¹...");
            const originLat = originPosition.lat;
            const originLng = originPosition.lng;
            let nearestKey = null;
            let nearestName = null;
            let minDist = Infinity;

            for (const key of Object.keys(stateObj)) {
                const [name, coordStr] = key.split('|');
                if (!coordStr) continue;
                const [latStr, lngStr] = coordStr.split(',');
                const lat = parseFloat(latStr);
                const lng = parseFloat(lngStr);
                if (Number.isNaN(lat) || Number.isNaN(lng)) continue;

                const d = haversineDistanceKm(originLat, originLng, lat, lng);
                if (d < minDist) {
                    minDist = d;
                    nearestKey = key;
                    nearestName = name;
                }
            }

            if (!nearestKey) throw new Error(`å· "${stateName}" ä¸­æ‰¾ä¸åˆ°ä»»ä½•å¯ç”¨åŸå¸‚æ•°æ®ã€‚`);
            cityKey = nearestKey;
            usedCityName = nearestName;
            
            locationInfoEl.innerHTML += `<br/><span style="font-size:0.9em; color:#667eea;">(å·²è‡ªåŠ¨åŒ¹é…æœ€è¿‘åŸå¸‚: ${usedCityName})</span>`;
        }

        const areaList = stateObj[cityKey];
        if (!Array.isArray(areaList) || areaList.length === 0) throw new Error(`åŸå¸‚ "${usedCityName}" æ²¡æœ‰é…ç½®å¯ç”¨çš„åŒºåŸŸã€‚`);

        // å‡†å¤‡ Matrix ç»ˆç‚¹
        const allDestinations = areaList
            .map(item => {
                const [areaName, coordStr] = item.split('|');
                if (!coordStr) return null;
                const [latStr, lngStr] = coordStr.split(',');
                const lat = parseFloat(latStr);
                const lng = parseFloat(lngStr);
                return (Number.isNaN(lat) || Number.isNaN(lng)) ? null : { name: areaName, coord: { lat, lng } };
            })
            .filter(Boolean);

        if (allDestinations.length === 0) throw new Error("æ²¡æœ‰æœ‰æ•ˆçš„åŒºåŸŸåæ ‡é…ç½®");

        // æ­¥éª¤ 3: åˆ†å—è°ƒç”¨ Matrix (ä¼˜åŒ–ï¼šå¹¶å‘ + é™é€Ÿ)
        // Radar Max Matrix Size: 25x25 (25 destinations per origin)
        // Rate Limit: 5 requests/sec. We use 220ms delay to be safe (~4.5 req/sec).
        const CHUNK_SIZE = 25;
        const REQUEST_DELAY_MS = 220; 

        // å‡†å¤‡æ‰€æœ‰çš„å—
        const chunks = [];
        for (let i = 0; i < allDestinations.length; i += CHUNK_SIZE) {
            chunks.push(allDestinations.slice(i, i + CHUNK_SIZE));
        }

        progressContainer.style.display = 'block';
        
        let completedChunks = 0;
        const totalChunks = chunks.length;

        // å®šä¹‰å¤„ç†å•ä¸ªå—çš„å‡½æ•°
        const processChunk = async (chunk) => {
            try {
                const chunkNames = chunk.map(d => d.name);
                const chunkCoords = chunk.map(d => d.coord);
                
                const matrixResponse = await getRadarMatrixData(originPosition, chunkCoords);
                const chunkResults = processRadarMatrixResults(chunkNames, matrixResponse);
                
                // æ›´æ–°è¿›åº¦
                completedChunks++;
                const percent = 60 + Math.floor((completedChunks / totalChunks) * 35);
                // ä»…æ›´æ–°æ–‡å­—ï¼Œä¸é˜»å¡
                progressText.textContent = `æ­£åœ¨è®¡ç®—è·¯å¾„: ${completedChunks} / ${totalChunks} æ‰¹æ¬¡...`;
                progressBar.style.width = `${percent}%`;

                return chunkResults;
            } catch (e) {
                console.error("Chunk failed:", e);
                return []; // å¤±è´¥çš„å—è¿”å›ç©ºæ•°ç»„ï¼Œé¿å…æ•´ä¸ªæµç¨‹ä¸­æ–­
            }
        };

        // åˆ›å»ºå¸¦å»¶è¿Ÿçš„ Promise é˜Ÿåˆ—
        const promises = chunks.map((chunk, index) => {
            return new Promise(resolve => {
                setTimeout(async () => {
                    const result = await processChunk(chunk);
                    resolve(result);
                }, index * REQUEST_DELAY_MS); // é”™å³°å‘èµ·è¯·æ±‚
            });
        });

        // ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
        const chunksResults = await Promise.all(promises);
        const allResults = chunksResults.flat();

        updateProgress(100, "è®¡ç®—å®Œæˆï¼Œæ­£åœ¨æ¸²æŸ“ç»“æœ...");
        displayResults(allResults, usedCityName, stateName, address);
        
        loadingEl.style.display = 'none';
        progressText.textContent = "âœ… æŸ¥è¯¢å®Œæˆï¼";

    } catch (error) {
        console.error(error);
        showError(error.message || "æŸ¥è¯¢å¤±è´¥");
    } finally {
        // loadingEl åœ¨ displayResults ä¸­å¤„ç†æˆ– error ä¸­å¤„ç†
        btn.disabled = false;
    }
}

// *** API æ ¸å¿ƒå‡½æ•° ***
async function geocodeAddress(address) {
    const encodedAddress = encodeURIComponent(address);
    const apiUrl = `https://api.radar.io/v1/geocode/forward?query=${encodedAddress}&publishableKey=${RADAR_PUBLISHABLE_KEY}`;

    const response = await fetch(apiUrl);
    const data = await response.json().catch(() => ({}));

    if (!response.ok) throw new Error(`Radar Geocoding Error: ${data.meta?.message || response.statusText}`);
    if (!data.addresses || data.addresses.length === 0) throw new Error("åœ°å€æ— æ•ˆæˆ–æ— æ³•è§£æ");

    const item = data.addresses[0];
    if (!item.state) throw new Error("æ— æ³•è§£æå‡ºå·ä¿¡æ¯ (Radar)");

    return {
        address: { state: item.state, city: item.city },
        position: { lat: item.latitude, lng: item.longitude }
    };
}

async function getRadarMatrixData(origin, destinations) {
    const originStr = `${origin.lat},${origin.lng}`;
    const destinationsStr = destinations.map(d => `${d.lat},${d.lng}`).join('|');
    const apiUrl = `https://api.radar.io/v1/route/matrix?origins=${originStr}&destinations=${destinationsStr}&mode=car&units=metric&publishableKey=${RADAR_PUBLISHABLE_KEY}`;

    const response = await fetch(apiUrl);
    const data = await response.json().catch(() => ({}));

    if (!response.ok) throw new Error(`Radar Matrix Error: ${data.meta?.message || response.statusText}`);
    if (!data.matrix) throw new Error("Matrixæ•°æ®ç¼ºå¤±");

    return data;
}

function processRadarMatrixResults(names, radarData) {
    if (!radarData || !radarData.matrix) return [];
    const row = radarData.matrix[0];
    if (!Array.isArray(row)) return [];

    const results = [];
    for (let i = 0; i < names.length; i++) {
        const item = row[i];
        if (item && item.distance && item.duration) {
            results.push({
                name: names[i],
                distance: item.distance.value, // meters
                time: item.duration.value * 60 // Radar minutes -> seconds
            });
        }
    }
    return results;
}

// *** è¾…åŠ©å‡½æ•° ***
function haversineDistanceKm(lat1, lon1, lat2, lon2) {
    const R = 6371; 
    const toRad = d => (d * Math.PI) / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lat2 === lat1 && lon2 === lon1 ? 0 : (lon2 - lon1));
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

function formatDuration(totalSeconds) {
    if (totalSeconds < 60) return "å°‘äº 1 åˆ†é’Ÿ";
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    let parts = [];
    if (hours > 0) parts.push(`${hours} å°æ—¶`);
    if (minutes > 0) parts.push(`${minutes} åˆ†é’Ÿ`);
    return parts.join(' ');
}

// *** UI æ“ä½œå‡½æ•° ***
function resetUI() {
    errorEl.style.display = 'none';
    resultsEl.innerHTML = '';
    locationInfoEl.style.display = 'none';
    locationInfoEl.innerHTML = '';
    progressContainer.style.display = 'none';
    progressBar.style.width = '0%';
    progressText.textContent = '';
    btn.disabled = true;
}

function showLoading(msg) {
    loadingEl.style.display = 'block';
    loadingTextEl.textContent = msg;
}

function updateProgress(percent, text) {
    progressContainer.style.display = 'block';
    progressBar.style.width = `${percent}%`;
    progressText.textContent = text;
}

function showError(msg) {
    loadingEl.style.display = 'none';
    errorEl.textContent = msg;
    errorEl.style.display = 'block';
    btn.disabled = false;
}

function displayResults(results, cityName, stateName, originInput) {
    if (results.length === 0) {
        resultsEl.innerHTML = `<p style="text-align:center; color:#7f8c8d;">åœ¨ "${cityName}" ä¸­æœªæ‰¾åˆ°å¯è®¡ç®—è·ç¦»çš„å…·ä½“åŒºåŸŸã€‚</p>`;
        return;
    }

    results.sort((a, b) => a.distance - b.distance);

    let tableRows = '';
    results.forEach(r => {
        const distanceKm = (r.distance / 1000).toFixed(1) + ' km';
        const duration = formatDuration(r.time);
        
        // æ„é€  Google Maps å¯¼èˆªé“¾æ¥ (æ–¹ä¾¿ç”¨æˆ·è·³è½¬)
        // ç›®æ ‡æ ¼å¼: AreaName, CityName, StateName
        const destQuery = `${r.name}, ${cityName}, ${stateName}`;
        const navUrl = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(originInput)}&destination=${encodeURIComponent(destQuery)}`;

        tableRows += `<tr>
            <td>${r.name}</td>
            <td>${cityName}</td>
            <td>${distanceKm}</td>
            <td>${duration}</td>
            <td><a class="nav-link" href="${navUrl}" target="_blank">ğŸ§­ å¯¼èˆª</a></td>
        </tr>`;
    });

    resultsEl.innerHTML = `
      <table>
        <thead><tr><th>ğŸ“ ç›®æ ‡åœ°ç‚¹</th><th>ğŸ™ï¸ æ‰€å±åŸå¸‚</th><th>ğŸ“ è·ç¦»</th><th>â±ï¸ é©¾è½¦æ—¶é—´</th><th>ğŸš— æ“ä½œ</th></tr></thead>
        <tbody>${tableRows}</tbody>
      </table>`;
}
</script>
</body>
</html>
